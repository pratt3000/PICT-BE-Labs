# -*- coding: utf-8 -*-
"""SCOA9.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UcSu0I5wVtKrV2v415rxW_HahTdVWCVa

# **PSO: TRAVELLING SALESMAN PROBLEM**
"""

import itertools
import numpy as np
np.random.seed(42)

class TSPParticleSwarm:
  def __init__(self, n, population_size, alpha, beta):
    self.n = n
    self.size = population_size
    self.alpha = alpha
    self.beta = beta
    self.nodes = np.arange(self.n)
    self.graph = [[0 if i == j else np.random.randint(20)+1 for i in range(self.n)] for j in range(self.n)]
    self.__init_population()

  def __fitness(self, x):
    fitness = 0
    for i in range(self.n):
      j = (i + 1) % self.n
      fitness += self.graph[x[i]][x[j]]
    return fitness

  def __get_gbest(self):
    gbest = self.pbest[0]
    for p in self.pbest:
      if self.__fitness(p) < self.__fitness(gbest):
        gbest = p
    return gbest

  def __init_population(self):
    self.population = [np.random.permutation(self.n) for _ in range(self.size)]
    self.velocity = [[tuple(np.random.choice(self.nodes, 2)) for _ in range(np.random.randint(self.n))] for _ in range(self.size)]
    # self.velocity = [[] for _ in range(self.size)]
    self.pbest = self.population.copy()
    self.gbest = self.__get_gbest()

  def add(self, x, ss):
    x = x.copy()
    for s in ss:
      x[s[0]], x[s[1]] = x[s[1]], x[s[0]]
    return x

  def sub(self, x, y, prob = 1):
    y = y.copy()
    ss = []
    for i in range(len(x)):
      j = np.where(y == x[i])[0][0]
      if np.random.rand() <= prob and i != j:
        ss.append((i, j))
        y[i], y[j] = y[j], y[i]
    return ss

  def __update_pbest(self):
    for i in range(self.size):
      if self.__fitness(self.population[i]) < self.__fitness(self.pbest[i]):
        self.pbest[i] = self.population[i].copy()

  def __reduce(self, ss):
    start = np.arange(self.n)
    end = self.add(start, ss)
    return self.sub(end, start)

  def __update_velocity(self):
    for i in range(self.size):
      self.velocity[i] = self.velocity[i] + self.sub(self.pbest[i], self.population[i], self.alpha) + self.sub(self.gbest, self.population[i], self.beta)
      self.velocity[i] = self.__reduce(self.velocity[i])

  def __update_population(self):
    for i in range(self.size):
      self.population[i] = self.add(self.population[i], self.velocity[i])

  def __perform_iteration(self):
    self.__update_pbest()
    self.gbest = self.__get_gbest()
    self.__update_velocity()
    self.__update_population()

  def display_population(self):
    for p in self.population:
      print(f'SEQUENCE: {p}, FITNESS: {self.__fitness(p)}')
    print()
    print(f'BEST PARTICLE: {self.gbest}, FITNESS: {self.__fitness(self.gbest)}')
    print()

  def get_graph(self):
    return self.graph

  def fit(self, iterations):
    print('INITIAL POPULATION:')
    self.display_population()
    for i in range(iterations):
      self.__perform_iteration()
      print(f'ITERATION {i+1}:')
      self.display_population()

  def best_solution(self):
    all_solutions = list(itertools.permutations(self.nodes))
    best_sol = all_solutions[0]
    for solution in all_solutions:
      if self.__fitness(solution) < self.__fitness(best_sol):
        best_sol = solution
    print(f'BEST SOLUTION: {best_sol}, FITNESS: {self.__fitness(best_sol)}')

population = TSPParticleSwarm(8, 16, 0.7, 0.8)

population.display_population()

population.fit(20)

population.best_solution()